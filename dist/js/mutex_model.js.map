{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./js/mutex_model.ts"],"names":["root","factory","exports","module","define","amd","a","i","this","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","FLAGS","models","options","model_map","Array","model_list","ncols","reduce","model","Math","max","col","colspan","dirty_data","_fill","MutexModel","USE_CHECK","FILL_EACHMODEL","append","setNCols","left_expand","splice","length","nincs","alloc","fill","clear","index","indexOf","count","undefined","remove","move","v2","flags","USE_OFFSET","getModel","row","format","rect","round","min","trim","height","ceil","changed_models","idx","nstep","_pathTest","push","nrows","max_offset","optimal_col","test_model","rowspan","max_col","offset","trimmed_rect","crossed_models","crossed_rect","cover","slice","calcWrap","_compress","sort","b","cascading_trimmed_rect","crossed_model","indenting_models","models_nrow","capture_models","capture_features","capture_nindents","new_capture_models","new_capture_features","new_capture_nindents","nindents","col_end","feature","loss_nindent","item","model_nindent","apply","Number","next_col","row_end","under_model","cm_idx","nindent","im_idx","map","USE_EACHOFFSET","concat","mask","result","right","wrap","calcOffset","origin_rect","target_rect","arg","next_model","isFinite","isNaN","list_index","pop","wrap_rect","ec","er","oc","or","ic","abs","ir","r_end","c_end","use_bw","vf","hf","f","trimmed_offset","lw","rw","bw","tw","sorted_directions","j","lastIndexOf"],"mappings":"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","file":"js/mutex_model.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","\r\nimport { Model, Rect, Options } from './interfaces';\r\n\r\nenum FLAGS {\r\n    USE_CHECK = 0x01,\r\n    FILL_EACHMODEL = 0x10,\r\n    USE_OFFSET = 0x100,\r\n    USE_EACHOFFSET = 0x1000,\r\n};\r\nclass MutexModel {\r\n    protected model_map: Array<Model | undefined> = new Array();\r\n    protected model_list: Array<Model> = new Array();\r\n    static FLAGS = FLAGS;\r\n    /**\r\n     * 与使用场景无关的js内存模型\r\n     * @param models \r\n     * @param options \r\n     */\r\n    constructor(\r\n        models: Array<Model> = [],\r\n        public options: Options = {}\r\n    ) {\r\n        if (!(this.options.ncols > 0)) {\r\n            this.options.ncols = models.reduce(\r\n                (ncols, model) => Math.max(ncols, (model.col || 0) + (model.colspan || 1))\r\n                , 1\r\n            );\r\n        }\r\n        let dirty_data = this._fill(models, MutexModel.FLAGS.USE_CHECK | MutexModel.FLAGS.FILL_EACHMODEL);\r\n        this.append(dirty_data);\r\n    }\r\n    get ncols(): number {\r\n        return this.options.ncols;\r\n    }\r\n    set ncols(ncols: number) {\r\n        this.setNCols(ncols);\r\n    }\r\n    /**\r\n     * 设置模型列数\r\n     * @param ncols 新的列数\r\n     * @param left_expand 如果为true表示为左扩展，也可以（-1 左 ，1右）\r\n     */\r\n    setNCols(ncols: number, left_expand?: boolean | number) {\r\n        if (ncols !== this.options.ncols) {\r\n            this.model_map.splice(0, this.model_map.length);\r\n            let model_list = this.model_list.splice(0, this.model_list.length);\r\n            if (left_expand && left_expand !== 1) {\r\n                let nincs = ncols - this.options.ncols;\r\n                for (const model of model_list) {\r\n                    model.col += nincs;\r\n                }\r\n            }\r\n            this.options.ncols = ncols;\r\n            for (const model of model_list) {\r\n                if (model.colspan > ncols) {\r\n                    model.colspan = ncols;\r\n                }\r\n                if (model.colspan + model.col > ncols) {\r\n                    model.col = ncols - model.colspan;\r\n                }\r\n            }\r\n            let dirty_data = this._fill(model_list, MutexModel.FLAGS.USE_CHECK | MutexModel.FLAGS.FILL_EACHMODEL);\r\n\r\n            for (const model of dirty_data) {\r\n                this.alloc(model as Rect);\r\n                this.fill(model);\r\n            }\r\n            /*\r\n            this.append(dirty_data);*/\r\n        }\r\n\r\n    }\r\n    /**\r\n     * 填充模型\r\n     * @param models \r\n     */\r\n    fill(models: Array<Model> | Model) {\r\n        models instanceof Array || (models = [models]);\r\n        this._fill(models, MutexModel.FLAGS.FILL_EACHMODEL);\r\n    }\r\n    /**\r\n     * 清除某个模型\r\n     * @param model \r\n     */\r\n    clear(model: Model) {\r\n        let index = this.model_list.indexOf(model), count = 0;\r\n        ~index && (this.model_list.splice(index, 1));\r\n        while (~(index = this.model_map.indexOf(model))) {\r\n            count++;\r\n            this.model_map[index] = undefined;\r\n        }\r\n        return count;\r\n    }\r\n    /**\r\n     * 移除模型\r\n     * @param models \r\n     */\r\n    remove(models: Array<Model> | Model) {\r\n        models instanceof Array || (models = [models]);\r\n        this._fill(models);\r\n    }\r\n    /**\r\n     * 移动某个或某组模型\r\n     * @param models \r\n     * @param v2 \r\n     * @param flags \r\n     */\r\n    move(models: Array<Model> | Model, v2: [number, number] | Array<[number, number]>, flags: number = 0) {\r\n        models instanceof Array || (models = [models]);\r\n        this.remove(models);\r\n        return this._fill(models, flags | MutexModel.FLAGS.FILL_EACHMODEL | MutexModel.FLAGS.USE_OFFSET, v2);\r\n    }\r\n    /**\r\n     * 指定 col row 捕获在这位于上方的模型\r\n     * @param col \r\n     * @param row \r\n     */\r\n    getModel(col: number, row: number): Model | undefined {\r\n        if (col >= 0 && row >= 0 && col < this.ncols) {\r\n            return this.model_map[col + row * this.ncols];\r\n        }\r\n    }\r\n    /**\r\n     * 规整化合适的位置\r\n     * @param rect \r\n     * @param col \r\n     * @param row \r\n     */\r\n    format(rect: Rect, col = rect.col, row = rect.row): Rect {\r\n        rect.col = Math.round(Math.max(Math.min(col, this.ncols - rect.colspan), 0));\r\n        rect.row = Math.round(Math.max(row, 0));\r\n        return rect;\r\n    }\r\n    /**\r\n     * 纵向剪裁掉模型空白区域（现在只有纵向）\r\n     */\r\n    trim(): Array<Model> {\r\n        let height = Math.ceil(this.model_map.length / this.ncols);\r\n        let changed_models = [];\r\n        for (let row = 1; row < height; row++) {\r\n            for (let col = 0; col < this.ncols; col++) {\r\n                let idx = row * this.ncols + col;\r\n                let model = this.model_map[idx];\r\n                if (model && model.row === row) {\r\n                    let nstep = this._pathTest([model], [0, -row - 1], model);\r\n                    if (nstep > 0) {\r\n                        changed_models.push(model);\r\n                        this.move([model], [0, -nstep]);\r\n                    }\r\n                    col += model.colspan - 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        return changed_models;\r\n    }\r\n    /**\r\n     * 自动寻找合适的地方加入模型\r\n     * @param models \r\n     */\r\n    append(models: Array<Model> | Model) {\r\n        models instanceof Array || (models = [models]);\r\n        for (const model of models) {\r\n            model.colspan > this.ncols && (model.colspan = this.ncols);\r\n            let nrows = Math.ceil(this.model_map.length / this.ncols);\r\n            let max_offset = 0, optimal_col = 0;\r\n            let test_model = { col: 0, row: nrows, colspan: model.colspan, rowspan: model.rowspan };\r\n            for (let col = 0, max_col = this.ncols - model.colspan; col <= max_col; col++) {\r\n                test_model.col = col;\r\n                let offset = this._pathTest([test_model], [0, -nrows - 1], test_model);\r\n                if (max_offset < offset) {\r\n                    max_offset = offset as number;\r\n                    optimal_col = col;\r\n                }\r\n            }\r\n            model.col = optimal_col;\r\n            model.row = nrows - max_offset;\r\n            this._fill([model], MutexModel.FLAGS.FILL_EACHMODEL);\r\n        }\r\n\r\n    }\r\n    /**\r\n     * 在指定位置开辟出指定大小的空间\r\n     * @param rect \r\n     * @param trimmed_rect \r\n     * @param crossed_models \r\n     * @param crossed_rect \r\n     */\r\n    alloc(\r\n        rect: Rect,\r\n        trimmed_rect: Rect = this.format(\r\n            { col: rect.col, row: rect.row, colspan: rect.colspan, rowspan: rect.rowspan }\r\n        ),\r\n        crossed_models: Array<Model> = this.cover(trimmed_rect),\r\n        crossed_rect?: Rect\r\n    ): Array<Model> {\r\n        let changed_models = crossed_models.slice();\r\n        if (crossed_models.length === 0) {\r\n            return changed_models;\r\n        }\r\n        crossed_rect || (crossed_rect = this.calcWrap(crossed_models));\r\n        if (\r\n            (\r\n                crossed_rect.colspan + crossed_rect.rowspan >\r\n                (trimmed_rect.colspan + trimmed_rect.rowspan) * 1.6\r\n            ) ||\r\n            !this._compress(trimmed_rect, crossed_models, crossed_rect, rect)\r\n        ) {\r\n            crossed_models.sort((a, b) => a.row - b.row);\r\n            let cascading_trimmed_rect = { ...trimmed_rect };\r\n            for (let i = 0; i < crossed_models.length; i++) {\r\n                let crossed_model = crossed_models[i];\r\n                if (\r\n                    this._compress(\r\n                        cascading_trimmed_rect,\r\n                        [crossed_model],\r\n                        crossed_model as Rect,\r\n                        undefined,\r\n                        false\r\n                    )) {\r\n                    crossed_models.splice(i--, 1);\r\n                } else {\r\n                    if (cascading_trimmed_rect.col > crossed_model.col) {\r\n                        cascading_trimmed_rect.colspan +=\r\n                            cascading_trimmed_rect.col - crossed_model.col;\r\n                        cascading_trimmed_rect.col = crossed_model.col;\r\n                    }\r\n                    if (\r\n                        cascading_trimmed_rect.col + cascading_trimmed_rect.colspan <\r\n                        crossed_model.col + crossed_model.colspan\r\n                    ) {\r\n                        cascading_trimmed_rect.colspan =\r\n                            crossed_model.col + crossed_model.colspan - cascading_trimmed_rect.col;\r\n                    }\r\n                }\r\n            }\r\n            if (crossed_models.length === 0) {\r\n                return changed_models;\r\n            }\r\n\r\n            let indenting_models: Model[] = [];\r\n            let models_nrow: number[] = [];\r\n\r\n            crossed_rect = this.calcWrap(crossed_models);\r\n            let colspan = trimmed_rect.colspan -\r\n                Math.max(crossed_rect.col - trimmed_rect.col, 0) -\r\n                Math.max(\r\n                    trimmed_rect.col + trimmed_rect.colspan -\r\n                    crossed_rect.colspan - crossed_rect.col\r\n                    , 0\r\n                );\r\n\r\n            let capture_models: Model[] = [\r\n                {\r\n                    col: Math.max(trimmed_rect.col, crossed_rect.col),\r\n                    row: trimmed_rect.row,\r\n                    colspan,\r\n                    rowspan: 0\r\n                }\r\n            ];\r\n            let capture_features: {\r\n                [key: number]: Array<{ row: number, rowspan: number }>\r\n            } = {};\r\n            let capture_nindents: Array<number[] | number> = [new Array(colspan).fill(trimmed_rect.rowspan)];\r\n\r\n\r\n            while (capture_models.length) {\r\n                let new_capture_models: Model[] = [];\r\n                let new_capture_features: {\r\n                    [key: number]: Array<{ row: number, rowspan: number }>\r\n                } = {};\r\n                let new_capture_nindents: Array<number[] | number> = [];\r\n                for (const key in capture_features) {\r\n                    capture_features[key].sort((a, b) => a.row - b.row);\r\n                }\r\n                for (let i = 0; i < capture_models.length; i++) {\r\n                    let model = capture_models[i];\r\n                    let nindents = capture_nindents[i] as Array<number>;\r\n                    for (let col = model.col, col_end = col + model.colspan; col < col_end; col++) {\r\n                        let feature = capture_features[col];\r\n                        if (feature) {\r\n                            let loss_nindent = 0;\r\n                            for (let index = 0; index < feature.length - 1; index++) {\r\n                                let item = feature[index];\r\n                                if (item.row < model.row) {\r\n                                    loss_nindent += feature[index + 1].row - (item.row + item.rowspan);\r\n                                } else {\r\n                                    break;\r\n                                }\r\n                            }\r\n                            nindents[col - model.col] -= loss_nindent;\r\n                        }\r\n                    }\r\n                    let model_nindent = Math.max.apply(Number, nindents);\r\n                    if (model_nindent > 0) {\r\n                        capture_nindents[i] = model_nindent;\r\n                        let index = indenting_models.indexOf(model);\r\n                        if (index === -1) {\r\n                            index = indenting_models.length;\r\n                            indenting_models.push(model);\r\n                            models_nrow.push(model_nindent);\r\n                        } else {\r\n                            if (models_nrow[index] >= model_nindent) {\r\n                                //console.log(models_nrow[index] , model_nindent);\r\n                                continue;\r\n                            } else {\r\n                                models_nrow[index] = model_nindent;\r\n                            }\r\n                        }\r\n                    } else {\r\n                        capture_models.splice(i, 1);\r\n                        capture_nindents.splice(i, 1);\r\n                        i--;\r\n                    }\r\n                }\r\n                for (let index = 0; index < capture_models.length; index++) {\r\n                    let model = capture_models[index];\r\n                    let model_nindent = capture_nindents[index] as number;\r\n                    next_col:\r\n                    for (let col = model.col, col_end = col + model.colspan; col < col_end; col++) {\r\n                        for (\r\n                            let row = model.row + model.rowspan, row_end = row + model_nindent;\r\n                            row < row_end;\r\n                            row++\r\n                        ) {\r\n                            let under_model = this.model_map[col + row * this.ncols];\r\n                            if (under_model) {\r\n                                let cm_idx = new_capture_models.indexOf(under_model);\r\n                                let nindents: number[];\r\n                                let nindent = row_end - row + Math.max(model.row - under_model.row, 0);\r\n                                if (cm_idx === -1) {\r\n                                    let im_idx = indenting_models.indexOf(under_model);\r\n                                    if (im_idx >= 0 && models_nrow[im_idx] >= nindent) {\r\n                                        continue next_col;\r\n                                    }\r\n                                    new_capture_models.push(under_model);\r\n                                    new_capture_nindents.push(nindents = new Array(under_model.colspan).fill(0));\r\n                                    let feature = new_capture_features[col] || (new_capture_features[col] = []);\r\n                                    feature.push({\r\n                                        row: under_model.row,\r\n                                        rowspan: under_model.rowspan\r\n                                    });\r\n                                } else {\r\n                                    nindents = new_capture_nindents[cm_idx] as number[];\r\n                                }\r\n                                nindents[col - under_model.col] = Math.max(nindents[col - under_model.col], nindent);\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                capture_models = new_capture_models;\r\n                capture_features = new_capture_features;\r\n                capture_nindents = new_capture_nindents;\r\n            }\r\n\r\n\r\n            indenting_models.splice(0, 1);\r\n            models_nrow.splice(0, 1);\r\n\r\n            this.move(indenting_models, models_nrow.map((row): [number, number] => [0, row]), MutexModel.FLAGS.USE_EACHOFFSET);\r\n            changed_models = changed_models.concat(indenting_models);\r\n        }\r\n        return changed_models;\r\n    }\r\n    /**\r\n     * 获得指定区域所包含的全部模型\r\n     * @param mask \r\n     */\r\n    cover(mask: Rect): Array<Model> {\r\n        let result = [];\r\n        let col = mask.col, row = mask.row;\r\n        for (let r = 0; r < mask.rowspan; r++) {\r\n            for (let c = 0; c < mask.colspan; c++) {\r\n                let model = this.model_map[(c + col) + (r + row) * this.ncols];\r\n                if (model !== undefined) {\r\n                    ~result.indexOf(model) || result.push(model);\r\n                    let right = model.colspan + model.col - 1;\r\n                    c + col < right && (c = right - col);\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * 计算能包含所有模型的最小矩形区域\r\n     * @param models \r\n     */\r\n    calcWrap(models: Array<Model>): Rect {\r\n        let wrap = {\r\n            col: models[0].col,\r\n            row: models[0].row,\r\n            colspan: models[0].colspan,\r\n            rowspan: models[0].rowspan\r\n        };\r\n        for (let i = 1; i < models.length; i++) {\r\n            let model = models[i];\r\n            wrap.col > model.col && (wrap.colspan += wrap.col - model.col, wrap.col = model.col);\r\n            wrap.row > model.row && (wrap.rowspan += wrap.row - model.row, wrap.row = model.row);\r\n            wrap.colspan + wrap.col < model.col + model.colspan &&\r\n                (wrap.colspan += model.col + model.colspan - wrap.col - wrap.colspan);\r\n            wrap.rowspan + wrap.row < model.row + model.rowspan &&\r\n                (wrap.rowspan += model.row + model.rowspan - wrap.row - wrap.rowspan);\r\n        }\r\n        return wrap;\r\n    }\r\n    /**\r\n     * 计算两区域的各向偏移\r\n     * @param flee_rect \r\n     * @param target_rect \r\n     */\r\n    calcOffset(origin_rect: Rect, target_rect: Rect) {\r\n        return {\r\n            l: origin_rect.col - (target_rect.col + target_rect.colspan),\r\n            r: origin_rect.col + origin_rect.colspan - target_rect.col,\r\n            t: origin_rect.row - (target_rect.row + target_rect.rowspan),\r\n            b: origin_rect.row + origin_rect.rowspan - target_rect.row,\r\n        }\r\n    }\r\n    private _fill(models: Model[], flags: number | undefined = 0, arg?: any): Array<Model> | undefined {\r\n        const FLAGS = MutexModel.FLAGS;\r\n        let dirty_data: Array<Model> | undefined = flags & FLAGS.USE_CHECK ? [] : undefined;\r\n        let model_map = this.model_map;\r\n        let model_list = this.model_list;\r\n        let ncols = this.ncols;\r\n        next_model:\r\n        for (let index = 0; index < models.length; index++) {\r\n            let model = models[index];\r\n\r\n\r\n            if (flags & FLAGS.USE_CHECK) {\r\n                isFinite(model.colspan) || (model.colspan = 1);\r\n                isFinite(model.rowspan) || (model.rowspan = 1);\r\n                if (isNaN(model.col + model.row) || model.col < 0 || model.col + model.colspan > ncols) {\r\n                    dirty_data.push(model);\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            let list_index = model_list.indexOf(model);\r\n            if (flags & FLAGS.FILL_EACHMODEL) {\r\n                if (list_index === -1) {\r\n                    model_list.push(model);\r\n                } else {\r\n                    continue;\r\n                }\r\n            } else {\r\n                if (list_index >= 0) {\r\n                    model_list.splice(list_index, 1);\r\n                }\r\n            }\r\n\r\n            if (flags & FLAGS.USE_EACHOFFSET) {\r\n                model.col += arg[index][0];\r\n                model.row += arg[index][1];\r\n            } else if (flags & FLAGS.USE_OFFSET) {\r\n                model.col += arg[0];\r\n                model.row += arg[1];\r\n            }\r\n            let { col, row, colspan, rowspan } = model;\r\n            //row + rowspan > this.nrows && (this.nrows = row + rowspan);\r\n            for (let r = 0; r < rowspan; r++) {\r\n                for (let c = 0; c < colspan; c++) {\r\n                    let idx = (c + col) + (r + row) * ncols;\r\n                    if (!(flags & FLAGS.USE_CHECK) || model_map[idx] === undefined) {\r\n                        model_map[idx] = flags & FLAGS.FILL_EACHMODEL ? model : arg;\r\n                    } else {\r\n                        do {\r\n                            while (c--) {\r\n                                model_map[(c + col) + (r + row) * ncols] = undefined;\r\n                            }\r\n                            c = colspan;\r\n                        } while (r--)\r\n                        flags & FLAGS.FILL_EACHMODEL && (model_list.pop());\r\n                        dirty_data.push(model);\r\n                        continue next_model;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return dirty_data;\r\n    }\r\n    private _pathTest(models: Model[], v2: [number, number], wrap_rect: Model = this.calcWrap(models)): number | boolean {\r\n        let ec = v2[0] | 0, er = v2[1] | 0, oc = 0, or = 0, nstep = 0;\r\n        let ic = ec && ec / Math.abs(ec), ir = er && er / Math.abs(er);\r\n        while (oc !== ec || or !== er) {\r\n            oc !== ec ? (oc = oc + ic) : (or = or + ir);\r\n            if (\r\n                wrap_rect.col + oc < 0 ||\r\n                wrap_rect.col + oc + wrap_rect.colspan > this.ncols ||\r\n                wrap_rect.row + or < 0\r\n            ) {\r\n                return nstep;\r\n            }\r\n            for (const model of models) {\r\n                for (let r = model.row, r_end = r + model.rowspan; r < r_end; r++) {\r\n                    for (let c = model.col, c_end = c + model.colspan; c < c_end; c++) {\r\n                        let idx = c + oc + (r + or) * this.ncols;\r\n                        if (this.model_map[idx] && models.indexOf(this.model_map[idx]) === -1) {\r\n                            return nstep;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            nstep += 1;\r\n        }\r\n        return true;\r\n    }\r\n    private _compress(\r\n        trimmed_rect: Rect,\r\n        crossed_models: Array<Model> = this.cover(trimmed_rect),\r\n        crossed_rect: Rect = this.calcWrap(crossed_models),\r\n        rect?: Rect,\r\n        use_bw = true\r\n    ): boolean {\r\n        let vf = crossed_rect.colspan / crossed_rect.rowspan;\r\n        let hf = trimmed_rect.rowspan / trimmed_rect.colspan;\r\n        let f = (vf + hf) / 4;\r\n        vf = f + vf / 2;\r\n        hf = f + hf / 2;\r\n        let trimmed_offset = this.calcOffset(trimmed_rect, crossed_rect);\r\n        let offset = rect ? this.calcOffset(rect, crossed_rect) : trimmed_offset;\r\n        let lw: any[] = [Math.abs(hf * offset.l), [trimmed_offset.l, 0]], rw: any[] = [Math.abs(hf * offset.r), [trimmed_offset.r, 0], lw];\r\n        lw.push(rw); rw.push(lw);\r\n        let tw: any[] = [Math.abs(vf * offset.t), [0, trimmed_offset.t]], bw: any[];\r\n        if (use_bw) {\r\n            bw = [Math.abs(vf * offset.b), [0, trimmed_offset.b]];\r\n            tw.push(bw); bw.push(tw);\r\n        }\r\n        let sorted_directions = (use_bw ? [lw, rw, tw, bw] : [lw, rw, tw]).sort((a, b) => a[0] - b[0]);\r\n        for (let i = 0; i < sorted_directions.length; i++) {\r\n            let j = sorted_directions.lastIndexOf(sorted_directions[i][2]);\r\n            if (j > i) {\r\n                sorted_directions.splice(j, 1);\r\n                sorted_directions.splice(i + 1, 0, sorted_directions[i][2]);\r\n            }\r\n            if (this._pathTest(crossed_models, sorted_directions[i][1], crossed_rect) === true) {\r\n                this.move(crossed_models, sorted_directions[i][1]);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\nexport default MutexModel;//这里糊一个根导出，让 MutexModel 可以在其他模块被定义\r\n//module.exports = MutexModel;//使用 module.exports 是为了import 和 require 都直接可用"],"sourceRoot":""}